# Import Built-Ins
import logging
import json
import threading
import time

# Import Third-Party
from websocket import create_connection, WebSocketTimeoutException,WebSocketConnectionClosedException
import requests
# Import Homebrew
from bitex.api.WSS.base import WSSAPI
from datetime import datetime

import gzip
# Init Logging Facilities
log = logging.getLogger(__name__)


class HuobiWSS(WSSAPI):
    def __init__(self,pair="btcusdt"):
        super(HuobiWSS, self).__init__('wss://api.huobi.pro/ws', 'Huobi')
        self.conn = None

        self.pairs = [pair.upper()]
        self._data_thread = None

    def start(self):
        super(HuobiWSS, self).start()

        self._data_thread = threading.Thread(target=self._process_data)
        self._data_thread.daemon = True
        self._data_thread.start()

    def stop(self):
        if self.running:
            super(HuobiWSS, self).stop()

            if self._data_thread:
                self._data_thread.join()
                self._data_thread = None

    def gen_id(self):
        return 'me'
    def _process_data(self):
        self.conn = create_connection(self.addr)

        # {
        #     "sub": "market.$symbol.trade.detail",
        #     "id": "id generated by client"
        # }
        id = self.gen_id()
        payload = json.dumps({"sub": "market."+self.pairs[0].lower()+".trade.detail", "id": id})
        self.conn.send(payload)
        while self.running:
            try:
                message = self.conn.recv()
                unzipped_data = gzip.decompress(message).decode()
                data = json.loads(unzipped_data)
                log.debug(data)

            except (WebSocketTimeoutException, ConnectionResetError,WebSocketConnectionClosedException):
                log.warning("restarted")
                self._controller_q.put('restart')
                time.sleep(3)
            except TypeError:
                log.warning("TypeError")
                pass


            # {'ch': 'market.btcusdt.trade.detail', 'ts': 1544186782193, 'tick': {'id': 31259035976, 'ts': 1544186782061,
            #                                                                     'data': [{'amount': 0.0014,
            #                                                                               'ts': 1544186782061,
            #                                                                               'id': 3125903597618694627503,
            #                                                                               'price': 3395.62,
            #                                                                               'direction': 'sell'},
            #                                                                              {'amount': 0.0062,
            #                                                                               'ts': 1544186782061,
            #                                                                               'id': 3125903597618694624947,
            #                                                                               'price': 3395.15,
            #                                                                               'direction': 'sell'}]}}
            if 'ch' in data:
                type = data['ch']
                # reason = data['reason']
                key  = "market."+self.pairs[0].lower()+".trade.detail"
                if type == key:
                    tick = data['tick']
                    tradedatas = tick['data']
                    for tradedata in tradedatas:

                        log.debug(tradedata)
                        amount = float(tradedata['amount'])
                        if tradedata['direction'] == "sell":
                            amount = -amount

                        timestamp = float(tradedata['ts'])

                        # print("ts %s" % timestamp)
                        self.data_q.put(('trades',
                                         timestamp, amount, float(tradedata['price']),))

            if 'ping' in data:
                payload = {"pong": data['ping']}
                self.conn.send(json.dumps(payload))

        self.conn = None